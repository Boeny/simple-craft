/**
 * Module calculates the points' positions on every request
 */
//var Light = require(MODULES+'/light');
var image = require(MODULES+'/image');

module.exports = {
	data: null,
	buffer: null,
	count: 2,// of the frames generated by the single request
	
	points: [],
	points_count: 1000,
	radius: 50,
	
	mass: 0,
	collision_distance: 1,
	temp_color_inc: 30,
	outer_mult: 0.005,
	
	// main process
	step: function(){
		//var result = {data: []};
		
		if (!__server.POST || !obj_length(__server.POST))
		{
			/*for (var i=0; i<this.count; i++){
				this.process();
				result.data.push(this.data);
			}*/
			
			var old = {};
			this.process(true, old);// fill old
			
			for (var i=0; i<this.count-2; i++){
				this.process();
			}
			this.process(false, old, true);// render
		}
		else{
			this.init();
			this.initialProcess();
			//result.data.push(this.data);
			//result.light_map = this.light.map;
		}
		
		return Buffer.from(this.buffer);
	},
	
	init: function(){
		var params = __server.POST;
		
		this.size = vget(params.width >> 0, params.height >> 0);// round
		this.size2 = vget(this.size.x >> 1, this.size.y >> 1);// / 2
		if (!this.radius) this.radius = Math.min(this.size2.x >> 1, this.size2.y >> 1);// / 2
		
		//this.light = new Light(this.size);
		image.size = this.size;
	},
	initialProcess: function(){
		this.points = [];
		this.buffer = new ArrayBuffer((this.size.x * this.size.y) << 2);// * 4
		this.data = new Uint32Array(this.buffer);
		
		//this.light.setCoo(vuno(0));
		this.outer_grav = vget(0,10);
		
		var p;
		
		for (var i=0; i<this.points_count; i++){
			p = randomInCircle(this.size2.x, this.size2.y, this.radius, true);// as float
			
			this.points.push({
				x: p.x,
				y: p.y,
				speed: vuno(0)
			});
			
			this.setFramePoint(p);
		}
		
		for (i=0; i<this.size.x; i++){
			this.points.push({
				x: i,
				y: this.size.y - 1,
				speed: vuno(0),
				fixed: true
			});
			this.setFramePoint(p);
		}
	},
	
	addOuterGrav: function(p){
		if (!this.outer_mult || p.fixed) return;
		
		vadd(p.speed, vmult(this.outer_grav, this.outer_mult, true));
		
		return;
		
		var d = vsub(this.outer_grav, p, true);
		var l = vlen(d);
		
		if (l < this.collision_distance) return;
		
		vmult(d, this.outer_mult/l);
		vadd(p.speed, d);
		//vsub(this.light.speed, this.mass/l);
	},
	
	process: function(bOld, old, bRender){
		var p, p2, l, d, tmp;
		
		for (var i=0; i<this.points_count; i++){
			p = this.points[i];
			this.addOuterGrav(p);
			if (p.fixed || !image.inScr(p)) continue;
			if (bOld) old[i] = image.getIndex(p);
			
			for (var j=i+1; j<this.points.length; j++){
				p2 = this.points[j];
				
				d = vsub(p2, p, true);
				l = vlen(d);
				
				if (l > this.collision_distance){
					//if (l < vlen(p.speed)){
						
					//}
					/*if (this.mass){
						vmult(d, this.mass/l);
						vadd(p.speed, d);
						vsub(p2.speed, d);
					}*/
				}
				else{// collision
					d = vset(d, l-this.collision_distance, true);// normalize and set the backward direction
					vadd(p, d);
					if (!p2.fixed) vsub(p2, d);
					
					d = vadd(p.speed, p2.speed, true);
					vmult(d, 0.5);
					p.speed = d;
					
					if (p2.fixed){
						p.speed = vuno(0);
						p.fixed = true;
					}
					else
						p2.speed = vcopy(d);
				}
			}
			
			vadd(p, p.speed);
			
			if (bRender) this.setFramePoint(p, old[i]);
		}
		
		//this.light.move();
	},
	
	// with color of temperature
	setFramePoint: function(p, old_index){
		p = image.roundCoo(p, true);
		if (!image.inScr(p)) return;
		
		var index = p.y * this.size.x + p.x;
		var c = this.data[index];
		
		if (c > 0 && old_index!=index){
			c += this.temp_color_inc;// red
			if (c > 0xFF0000FF) c = 0xFF0000FF;
		}
		
		/*else{
			image.setColor(this.data, p, c);
			this.light.apply(this.data, p);
		}*/
		
		if (old_index > -1 && old_index != index) this.data[old_index] = 0;
		this.data[index] = c || 0xFF000000;// 4 bytes (a,b,g,r)
	},
	clearFramePoint: function(p){
		var index = image.getIndex(p);
		if (index > -1) this.data[index] = 0;
	},
	
	tail: 1,// px
	setTail: function(){
 		if (!this.tail || !this.history.length) return;
 		
		var old, opacity;
		var step = Math.round(255/this.tail);
		var i = 0;
		var c;
		
		do {
			old = this.history[t];
			opacity = i*step;
			
			for (var y in old)
			for (var x in old[+y]){
				x = +x;
				y = +y;
				
				if (!this.data[y] || !this.data[y][x])
				{
					check_obj(this.data, y, {});
					c = this.c.getColorAt(this.img, x, y);
					this.data[y][x] = {r: c.r, g: c.g, b: c.b, a: opacity};
				}
			}
			
			i++;
			t++;
		}
		while(t < index);
 	}
};
